
import os
import psycopg2
import psycopg2.extras
import tabulate
from dotenv import load_dotenv

# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor)
    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    
    _global = []
    
    import re
    
    # read the query file
    with open('query2.txt', 'r') as f:
        lines = [line.strip() for line in f.readlines() if line.strip()]

    S = [t.strip() for t in lines[0].split(',')]
    n = int(lines[1])
    V = [t.strip() for t in lines[2].split(',')]
    F = [t.strip() for t in lines[3].split(',')]
    P_List = [t.strip() for t in lines[4].split(',')]
    G = lines[5]

    # break down the predicates
    pred_map = {}
    for pred in P_List:
        gv, rest = pred.split('.', 1)
        pred_map.setdefault(gv.strip(), []).append(rest.strip())

    
    mf_struct = {}
    avg_dict = {}

    #run through the first scan
    for row in cur:
        gb_attr = '_'.join(str(row[attr]) for attr in V) #key for MF
        

        for gv_num, preds in pred_map.items():
            # all predicates of this gv must pass
            ok = True
            for p in preds:
                attr, val = p.split('=', 1)
                attr = attr.strip()
                val = val.strip().strip("'\"")
                if str(row[attr]) != val:
                    ok = False
                    break
            mf_struct.setdefault(gb_attr, {})
            if not ok:
                continue
                

            # update every aggregate that belongs to this gv_num
            for tag in F:
                try:
                    gnum, func, col = tag.split('_', 2)
                except ValueError:
                    raise ValueError(f"bad aggregate tag: {tag!r}")
                if gnum != gv_num:
                    continue

                if func == 'sum':
                    mf_struct[gb_attr][tag] = mf_struct[gb_attr].get(tag, 0) + row[col]
                elif func == 'count':
                    mf_struct[gb_attr][tag] = mf_struct[gb_attr].get(tag, 0) + 1
                elif func == 'min':
                    mf_struct[gb_attr][tag] = min(mf_struct[gb_attr].get(tag, row[col]), row[col])
                elif func == 'max':
                    mf_struct[gb_attr][tag] = max(mf_struct[gb_attr].get(tag, row[col]), row[col])
                elif func == 'avg':
                    ad = avg_dict.setdefault(gb_attr, {}).setdefault(tag, {'sum':0, 'cnt':0})
                    ad['sum'] += row[col]; ad['cnt'] += 1
                    mf_struct[gb_attr][tag] = ad['sum'] / ad['cnt']

    #look at HAVING attr
    if G.lower() != 'none':
        tag_pattern = r'\b\d+_[A-Za-z0-9_]+\b'
        expr = re.sub(tag_pattern, lambda m: f'v[{m.group(0)!r}]', G)

        passed = {}
        for k, v in mf_struct.items():
            try:
                if eval(expr, {"__builtins__": None}, {"v": v}):
                    passed[k] = v
            except Exception:
                # any errors get treated as false
                pass
        mf_struct = passed

    # for output
    mf_struct = {
        k: {agg: v[agg] for agg in F if agg in v}
        for k, v in sorted(mf_struct.items())
    }

    for k, aggs in mf_struct.items():
        key_dict = dict(zip(V, k.split('_')))
        row = {**key_dict, **aggs}
        #   ensure every column in S is present even if missing
        for col in S:
            row.setdefault(col, None)
        _global.append(row)
        # global needs to be dict for tabulate to work
    
    
    return tabulate.tabulate(_global,
                        headers="keys", tablefmt="psql")

def main():
    print(query())
    
if "__main__" == __name__:
    main()
    