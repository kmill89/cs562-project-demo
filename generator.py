import subprocess


def main():
    """
    This is the generator code. It should take in the MF structure and generate the code
    needed to run the query. That generated code should be saved to a 
    file (e.g. _generated.py) and then run.
    """

    body = """
    import re

    _global = []

    with open('query.txt', 'r') as f:
        lines = [line.strip() for line in f.readlines() if line.strip()]

    S = lines[0].split(',')
    n = int(lines[1])
    V = lines[2].split(',')
    F = lines[3].split(',')
    P_List = lines[4].split(',')
    G = lines[5]

    mf_struct = {}
    avg_dict = {}

    for row in cur:
        gb_attr = '_'.join(str(row[attr]) for attr in V)
        if gb_attr not in mf_struct:
            mf_struct[gb_attr] = {}
            #Initalize dictionary for the group by attribute
        for pred in P_List:
            gv, rest = pred.split('.', 1)
            attr, val = rest.split('=')
            gv_num = gv.strip()
            #Parses conditions in the list of predicates
            if str(row[attr.strip()]) != val.strip():
                continue
            for agg in F:
                func, gnum, col = agg.split('_')
                if gnum != gv_num or col != attr.strip():
                    continue
                    # Skip if current aggregate isn't for the current grouping variable
                if func == 'sum':
                    mf_struct[gb_attr][agg] = mf_struct[gb_attr].get(agg, 0) + row[col]
                    #Increment total sum
                elif func == 'count':
                    mf_struct[gb_attr][agg] = mf_struct[gb_attr].get(agg, 0) + 1
                    #Increment count by 1
                elif func == 'min':
                    mf_struct[gb_attr][agg] = min(mf_struct[gb_attr].get(agg, row[col]), row[col])
                    #Store minimum value
                elif func == 'max':
                    mf_struct[gb_attr][agg] = max(mf_struct[gb_attr].get(agg, row[col]), row[col])
                    #Store maximum value
                elif func == 'avg':
                    if gb_attr not in avg_dict:
                        avg_dict[gb_attr] = {}
                    if agg not in avg_dict[gb_attr]:
                        avg_dict[gb_attr][agg] = {'sum': row[col], 'count': 1}
                    else:
                        avg_dict[gb_attr][agg]['sum'] += row[col]
                        avg_dict[gb_attr][agg]['count'] += 1
                    mf_struct[gb_attr][agg] = avg_dict[gb_attr][agg]['sum'] / avg_dict[gb_attr][agg]['count']
                    # Update tracking of count and sum; then calculate the average

    def check(g1, operator, g2, row):
        #
        if operator == '<': return row[g1] < row[g2]
        if operator == '>': return row[g1] > row[g2]
        if operator == '<=': return row[g1] <= row[g2]
        if operator == '>=': return row[g1] >= row[g2]
        if operator == '==': return row[g1] == row[g2]
        if operator == '!=': return row[g1] != row[g2]

    if G != 'None':
        parts = G.split()
        temp = {}
        g1, op, g2 = parts[0], parts[1], parts[2]
        for k, v in mf_struct.items():
            if check(g1, op, g2, v):
                temp[k] = v
        for i in range(3, len(parts), 4):
            andor, g1, op, g2 = parts[i:i+4]
            if andor == 'or':
                for k, v in mf_struct.items():
                    if check(g1, op, g2, v):
                        temp[k] = v
            elif andor == 'and':
                for k in list(temp):
                    if not check(g1, op, g2, temp[k]):
                        temp.pop(k)
        mf_struct = temp

    for k, v in mf_struct.items():
        new_row = k.split('_') + [v.get(f, None) for f in F]
        _global.append(new_row)
    """

    # Note: The f allows formatting with variables.
    #       Also, note the indentation is preserved.
    tmp = f"""
import os
import psycopg2
import psycopg2.extras
import tabulate
from dotenv import load_dotenv

# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor)
    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    
    _global = []
    {body}
    
    return tabulate.tabulate(_global,
                        headers="keys", tablefmt="psql")

def main():
    print(query())
    
if "__main__" == __name__:
    main()
    """

    # Write the generated code to a file
    open("_generated.py", "w").write(tmp)
    # Execute the generated code
    subprocess.run(["python3", "_generated.py"])


if "__main__" == __name__:
    main()
