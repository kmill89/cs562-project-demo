import subprocess


def main():
    """
    This is the generator code. It should take in the MF structure and generate the code
    needed to run the query. That generated code should be saved to a 
    file (e.g. _generated.py) and then run.
    """

    body = """
    import re
    # read the query file
    with open('query.txt', 'r') as f:
        lines = [line.strip() for line in f.readlines() if line.strip()]

    S = lines[0].strip().split(',')
    n = int(lines[1])
    V = lines[2].strip().split(',')
    F = lines[3].strip().split(',')
    P_List = lines[4].strip().split(',')
    G = lines[5]

    # break down the predicates
    pred_map = {}
    for pred in P_List:
        gv, rest = pred.split('.', 1)
        pred_map.setdefault(gv.strip(), []).append(rest.strip())

    
    mf_struct = {}
    avg_dict = {}

    #run through the first scan
    for row in cur:
        gb_attr = '_'.join(str(row[attr]) for attr in V) #key for MF
        mf_struct.setdefault(gb_attr, {}) #creates row if it doesn't exist

        for gv_num, preds in pred_map.items():
        # all predicates of this gv must pass
            ok = True
            for p in preds:
                attr, val = p.split('=', 1)
                attr = attr.strip()
                val = val.strip().strip("'\"")
                if str(row[attr]) != val:
                    ok = False
                    break
            if not ok:
                continue
                

            # update every aggregate that belongs to this gv_num
            for tag in F:
                try:
                    gnum, func, col = tag.split('_', 2)
                except ValueError:
                    raise ValueError(f"bad aggregate tag: "{tag}"")
                if gnum != gv_num:
                    continue

                if func == 'sum':
                    mf_struct[gb_attr][tag] = mf_struct[gb_attr].get(tag, 0) + row[col]
                elif func == 'count':
                    mf_struct[gb_attr][tag] = mf_struct[gb_attr].get(tag, 0) + 1
                elif func == 'min':
                    mf_struct[gb_attr][tag] = min(mf_struct[gb_attr].get(tag, row[col]), row[col])
                elif func == 'max':
                    mf_struct[gb_attr][tag] = max(mf_struct[gb_attr].get(tag, row[col]), row[col])
                elif func == 'avg':
                    ad = avg_dict.setdefault(gb_attr, {}).setdefault(tag, {'sum':0, 'cnt':0})
                    ad['sum'] += row[col]; ad['cnt'] += 1
                    mf_struct[gb_attr][tag] = ad['sum'] / ad['cnt']

    #look at having attr
    def check(g1, operator, g2, row):
        if operator == '<': return row[g1] < row[g2]
        if operator == '>': return row[g1] > row[g2]
        if operator == '<=': return row[g1] <= row[g2]
        if operator == '>=': return row[g1] >= row[g2]
        if operator == '==': return row[g1] == row[g2]
        if operator == '!=': return row[g1] != row[g2]

    if G != 'None':
        token_pattern = r"[A-Za-z0-9_\.]+|>=|<=|!=|==|[><=+*/()-]"
        parts = re.findall(token_pattern, G) 
        temp = {}
        g1, op, g2 = parts[0], parts[1], parts[2]
        for k, v in mf_struct.items():
            if check(g1, op, g2, v):
                temp[k] = v
        for i in range(3, len(parts), 4):
            andor, g1, op, g2 = parts[i:i+4]
            if andor == 'or':
                for k, v in mf_struct.items():
                    if check(g1, op, g2, v):
                        temp[k] = v
            elif andor == 'and':
                for k in list(temp):
                    if not check(g1, op, g2, temp[k]):
                        temp.pop(k)
        mf_struct = temp

    # for output
    for k, aggs in mf_struct.items():
        key_dict = dict(zip(V, k.split('_')))
        row = {**key_dict, **aggs}
        #   ensure every column in S is present even if missing
        for col in S:
            row.setdefault(col, None)
        _global.append(row)
        # global needs to be dict for tabulate to work
    """

    # Note: The f allows formatting with variables.
    #       Also, note the indentation is preserved.
    tmp = f"""
import os
import psycopg2
import psycopg2.extras
import tabulate
from dotenv import load_dotenv

# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor)
    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    
    _global = []
    {body}
    
    return tabulate.tabulate(_global,
                        headers="keys", tablefmt="psql")

def main():
    print(query())
    
if "__main__" == __name__:
    main()
    """

    # Write the generated code to a file
    open("_generated.py", "w").write(tmp)
    # Execute the generated code
    subprocess.run(["python3", "_generated.py"])


if "__main__" == __name__:
    main()
